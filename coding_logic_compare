import json
import os
import time
import pandas as pd
from google import genai
from google.colab import userdata
# Importing the new list name
from preprocessing_modelcompare import clean_raw_text, AI_CONFIG, MODELS_TO_TEST

# --- INITIALIZATION ---
client = genai.Client(api_key=userdata.get('GEMINI_API_KEY'))

with open('codebook.json', 'r') as f:
    CODEBOOK_DICT = json.load(f)

INPUT_FILE = "Test1500.csv"
OUTPUT_FILE = "model_comparison_results.csv" # New name for the test
SAVE_INTERVAL = 10
TOTAL_EXPECTED = 298 # Based on your sample size

SYSTEM_PROMPT = f"""

  
### NEGATIVE CONSTRAINTS (THE "NO-GO" ZONE)
‚Ä¢	NO INVENTED CODES: Use ONLY the exact wording of the code keys as provided in the JSON Codebook (CODEBOOK_DICT).  Do not summarize or combine code names.  Each code must be its own distinct entry.
‚Ä¢	NO INFERENTIAL CODING: Literal Evidence Only: You MUST only apply codes for intents explicitly stated by the patron or services performed by the librarian. DO NOT
‚Ä¢	Prohibited Language: In your reasoning, you are strictly forbidden from using words like "implies," "suggests," "could lead to," or "might mean".
‚Ä¢	DO NOT INFER FORMATS: Example - Music Scores = 'Known Item: Other'. Never 'Known Item: AV‚Äô
‚Ä¢	DO NOT INFER COURSE RESERVES: Do not assume a student needs 'Course Reserves' solely because their need mentions a class (ex. HUMS 150) or course (Applied Physics).
‚Ä¢	DO NOT INFER ADDITIONAL IMPACTS: Do not infer secondary impacts (e.g., air conditioning issues do not automatically mean 'Noise Issues‚Äô, bad odors do not mean ‚ÄòNoise Issues‚Äô).

### CORE LOGIC.
‚Ä¢	Keyword Contextualization: Map keywords to the "Intent" and "Definition" sections of the Codebook. Do not infer meaning not supported by a keyword.
‚Ä¢	Multi-Labeling: Assign all relevant codes if a transcript touches multiple topics.  Separate with commas.  
‚Ä¢	Topic/Genre: If patron starts with a topic, subject or category (e.g., "poetry books") rather than a known item, code as 'Finding relevant sources'.
‚Ä¢	Origin-Based Coding: A Known Item code (Book, Article, AV) can ONLY be triggered if the specific or unique item details (title, URL, etc.) originates from the Patron (including as a specific patron clarification e.g., "Yes, I'm looking for a book called X").
  ‚Ä¢	Confirmation Rule: If a patron merely acknowledges or "mentions" a title first introduced by the Librarian (e.g., "Yes, that's the Kansas City Star article I need"), it remains a result of Finding Relevant Resources, not a Known Item request.
‚Ä¢	Noun-First Rule. Anchor first on the Object requested by the patron (the book, the report, the VR headset, the website). If a specific item is requested (the Noun), that is the Primary Intent. 
‚Ä¢	Librarian Source Rule: If it is the Librarian who suggests a specific resource (e.g., "Try the book 'Jazz Origins' or ‚ÄúWatch the film ‚ÄòGone with the Wind‚Äô‚Äù) this is a product of search and discovery, do NOT use 'Known Item'. 
‚Ä¢	Known Item Logical Immunity:
  ‚Ä¢	Purpose-Neutral: patron's goal for ‚Äòknown item‚Äô request (e.g., literature review, lab report) does not change the known item request into a topic search.
  ‚Ä¢	Availability-Neutral: Availability is not Intent. A search failure, referral to "Interlibrary Loan" or connectivity issue does not change the ‚ÄòKnown Item‚Äô intent. Do not change a ‚ÄòKnown Item‚Äô primary intent due to search or access failure or other secondary intents.
  ‚Ä¢	Quantity-Neutral: Multiple ‚ÄòKnow Item‚Äô requests (e.g. patron provided titles provided for three separate articles and a book) do not aggregate into a topic or subject search; the primary intent remains [Known Item: Format(s)] request.
‚Ä¢	Metadate Density Rule: If the patron provides a Title + Author, apply both [Known Item: Format] AND [Find Item by Author]. This captures the full metadata density of the request.
‚Ä¢	Role-Based Anchor (Faculty Instructional Support)
  o	Explicit Identity Required: Only apply Faculty Instructional Support if the user explicitly identifies as the teacher or instructor (e.g., "I am the professor," "for my students").
  o	No Inference from "Class": Do not assume a user is Faculty or Staff just because they mention a class (ex. HUMS 150) or course (Applied Physics) or uses "class," "assignment," or "research paper." Most students use these terms.
  o	Professional Capacity: Do NOT use Faculty Instructional Support if the user is staff/faculty but the request is for their own individual research or personal use (not for a course they are teaching).
‚Ä¢	Research Spectrum (Decision Tree)
  o	Develop Research Topic: Use if the Patron is still refining the idea or focus of their project.
  o	Research Strategies: Use if the Patron has a topic but needs a pathway (keywords, specific databases to try).
  o	Database Search Skills: Use if the Librarian is teaching the mechanical use of a tool (how to use filters, Boolean operators, or interface features).
‚Ä¢	Possession Rule: If a patron is "returning" or "bringing back" an item or claims it was already returned, it is NOT lost. DO NOT code it as 'Lost Items'.
‚Ä¢	Building Maintenance: Inquiries regarding building comfort or maintenance such as HVAC (Air Conditioning/Heating), plumbing (leaks), lighting, or elevators are NOT related to Hours, Navigation & Wayfinding, or Noise Issues. You MUST use the code ‚ÄòOther‚Äô. 
‚Ä¢	Library Web Navigation: Code as ‚ÄòWebsite‚Äô if the interaction involves troubleshooting the Library Website interface (e.g., "click here," "scroll down," "I can't find it on the page"). This includes finding hours or info via the site's layout.
‚Ä¢	Policy: Any question regarding permission or rules for the library (e.g., "Am I allowed to...?", "Can I bring coffee?", ‚ÄúAs an alumni, can I use‚Ä¶?‚Äù) MUST include the ‚ÄòPolicies & Procedures‚Äô code.
‚Ä¢	Abandoned Chat: if there is zero evidence of a library-related inquiry with only items like greetings, thank you, nonsensical words or is blank, code as 'Abandoned Chat' If the librarian provides a link or discusses a policy, the chat is Active, even if the patron only says "Thank you". 
‚Ä¢	Tech Renewals: If the user is renewing or returning a technology-based item, use 'Renewals' first and 'Borrow Tech' second.  Do NOT use ‚ÄòKnown Item‚Äô for technology-based hardware.
‚Ä¢	Physical Wayfinding: If a permission or access question involves a specific library physical space (e.g., "Are the stacks open to community users?"), apply both ‚ÄòPolicies & Procedures‚Äô and ‚ÄòNavigation & Wayfinding‚Äô
‚Ä¢	Campus Service Priority: If a librarian refers a patron to a non-library, university entity (Bookstore, Bursar, Financial Aid), the code ‚ÄòCampus Services‚Äô is mandatory.

### FEW-SHOT EXAMPLES (THE ANCHORS)
Transcript: "I need to renew my laptop, are you open until 7?" is Code: Renewals, Borrow Tech, Hours | Reasoning: 'Renewals' for extension request, 'Borrow Tech' for the laptop, 'Hours' for the time inquiry.
Transcript: ‚ÄúI am a faculty member and I need a US Census dataset for my research paper‚Äù is Code: Known Item: Other | Reasoning: Patron is asking for known dataset for their own research project unrelated to teaching a class.
Transcript: "I want to donate 50 books on the Mayans." is Code: Other | Reasoning: 'Donations' is not a valid code; map to 'Other'.
Transcript: "My password is not working for the library link." Code: Connectivity & Remote Access Issues, Patron Accounts | Reasoning: Technical barrier to accessing digital resources, password issue with account.
Transcript: "I will just purchase the textbook myself." Code: Other | Reasoning: User is discussing buying the item themself. 'Request Purchase' is limited to the user asking the library to purchase or license access to an item.
Transcript: "Do you have the New York Times?" Code: Known Item: Articles | Reasoning: User is asking for a journal, newspaper or magazine by its title.

### RESPONSE FORMAT
Code, Code | [Reasoning: Brief justification for inclusion/exclusion]

### CODEBOOK JSON:
{json.dumps(CODEBOOK_DICT, indent=2)}
"""
# FIX 1: Pass model_id into the function
def code_transcript(transcript, model_id):
    """
    Orchestrates the API call with the specific model requested.
    """
    cleaned_input = clean_raw_text(transcript)
    if len(cleaned_input) < 10:
        return "Abandoned Chat | Insufficient data"

    coffee_reminder = "\n\n### PRECISION CHECK: Identify all distinct categories. Use 'Other' if no fit. Do not stretch definitions."
    last_error = "Unknown Error"

    for attempt in range(3):
        try:
            # FIX 2: Use the model_id passed from the loop
            response = client.models.generate_content(
                model=model_id,
                contents=f"{SYSTEM_PROMPT}\n\nTranscript: {cleaned_input}{coffee_reminder}",
                config=AI_CONFIG 
            )
            return response.text.replace("**", "").replace("\n", " ").strip()
            
        except Exception as e:
            last_error = str(e)
            time.sleep(5)
    
    return f"ERROR | {last_error[:50]}"

def main():
    if os.path.exists(OUTPUT_FILE):
        df = pd.read_csv(OUTPUT_FILE)
    else:
        df = pd.read_csv(INPUT_FILE)

    # FIX 3: Create separate columns for the two models
    for m_id in MODELS_TO_TEST:
        col_name = f"Results_{m_id}"
        if col_name not in df.columns:
            df[col_name] = ""
        df[col_name] = df[col_name].astype(str)
   
    processed_this_session = 0
    
    try:
        for i, row in df.iterrows():
            # Check if both models have already run for this row
            all_done = all(pd.notnull(df.at[i, f"Results_{m}"]) and "ERROR" not in str(df.at[i, f"Results_{m}"]) and df.at[i, f"Results_{m}"].strip() != "" for m in MODELS_TO_TEST)
            if all_done: continue

            print(f"üìù [{i+1}/{len(df)}] Comparing Models...")
            
            # FIX 4: Loop through both models for the same transcript
            for m_id in MODELS_TO_TEST:
                col_name = f"Results_{m_id}"
                # Only run if this specific model hasn't finished this row
                if "ERROR" in str(df.at[i, col_name]) or df.at[i, col_name].strip() == "":
                    df.at[i, col_name] = code_transcript(row['Transcript'], m_id)
            
            processed_this_session += 1

            if processed_this_session % SAVE_INTERVAL == 0:
                df.to_csv(OUTPUT_FILE, index=False)
                print(f"üíæ Saved Checkpoint at row {i+1}")
                      
            time.sleep(1.0) 

    except KeyboardInterrupt:
        print("\nüõë Manual stop.")
    finally:
        df.to_csv(OUTPUT_FILE, index=False)
        print(f"üèÅ Final Save Complete. Session Total: {processed_this_session}")

if __name__ == "__main__":
    main()
